# TLS decryption in Wireshark

When I spoke with some people I found out that most of them had some hard time with TLS decryption in world's foremost and widely-used network protocol
analyzer “Wireshark”.

TLS decryption could be very useful when we are analyzing some potential malicious web traffic or simply troubleshooting our own web server.

One of the method, I will be mentioning, works for every case covering situation like network traffic decryption of our web browser client “Google Chrome,
Firefox, Python…”. The second method covers situations where we have RSA Private key of web server and captured network traffic as “.pcap, .pcapng…” or we are
performing live network capturing. The second method, using RSA private key is also applicable for TLS decryption of different protocol than HTTP.

Both of these methods have their advantages and disadvantages.

This little post is about TLS decryption possibilities in Wireshark and I hope
it will serve someone as a simple guide.<br/>
<br/>

## Let´s start

As mentioned before, Wireshark supports TLS decryption when appropriate secrets
are provided. The two available methods are:

-   Key log file using per-session secrets (Using the (Pre)-Master-Secret)

-   Decryption using RSA private key
<br/>

## Using the (Pre)-Master-Secret

This method used for TLS decryption is using pre-master key logging. It is very
simple and quick to set up but works only with some web browser clients
(example: Google Chrome, Firefox, Python).

It works thanks to setting up the environment variable “SSLKEYLOGFILE”. The
value of this environment variable is path, pointing to some writable location
where our key logging file will be created. Mentioned web browser clients check
this environment variable and if it is set, they are able to log there
per-session secrets which are immediately used in Wireshark.

Advantage of this method is that it works in every case (SSL3. TLS1.0 -1.3),
also when TLS cipher suite selected by the server is using (EC)DHE for key
exchange algorithm.

We start with setting environment variable “SSLKEYLOGFILE”. As we can see in the
picture below: (“SSLKEYLOGFILE =
C:\\Users\\DFIR_GUY\\Desktop\\wireshark_decrypt_https\\keylogfile.txt”)

![](media/03ca84eb6a6c7bea0ec19e6ff825c034.png)

After that, we have to set this path to Key log file containing our per-session
secrets in Wireshark.

Start Wireshark and go to -\> Edit -\> Preferences -\> Protocols -\> TLS -\> Pre
Master-Secret log filename. Set the appropriate path as we set before in
environment variable.

![](media/4c6d2eed40dfe01e6f4e42f638c54007.png)

Now we are ready. Below is a network traffic of Google Chrome before and after
setting the Key log file containing our per-session secrets:

Before (No HTTP traffic available):

![](media/c35a0fcc538223085e08f4937f67b9b1.png)

49\. packet after TLS Handshake – Only TLS encrypted application data.

![](media/8da6dddc093da86ae3a17b7d661e0398.png)

After:

![](media/e0e9f4fd1539260e8d19e6ec82909fd2.png)

49\. packet after TLS Handshake – TLS decrypted application data HTTP2.

![](media/dbd1325e1dee7310a249ae8f28d0c9fb.png)
<br/>
<br/>
## Using RSA private key

This method works in case where we own or get the RSA private key. It is
applicable also for TLS decryption of different protocol than HTTP.

One of the limitations of using this method is that only SSL3, TLS1.0 -1.2 must
be used. There is no support for TLS version 1.3. Another limitation is that
(EC)DHE key exchange algorithm specified in the cipher suites must not be used
because of principle how (EC)DHE key exchange algorithms work.

According to Wireshark docs only in these cases RSA private key method could be
used:

-   The cipher suite selected by the server is not using (EC)DHE.

-   The protocol version is SSLv3, (D)TLS 1.0-1.2. It does not work with TLS
    1.3.

-   The private key matches the server certificate. It does not work with the
    client certificate, nor the Certificate Authority (CA) certificate.

-   The session has not been resumed. The handshake must include the
    ClientKeyExchange handshake message.
<br/>
So if we own the web server RSA private key and can manage to use supported
version of TLS + not using cipher suites implementing (EC)DHE key exchange
algorithm, we can successfully decrypt the TLS traffic.

These restrictions we can configure on the client side (web browser client) for
example: to use only TLS 1.2 and cipher suites not using (EC)DHE key exchange
algorithm but after that it all depends on server side if it enables to perform
TLS handshake using these specified parameters.

I will be focusing on how we can configure the server side to enable only TLS1.2
and cipher suites not using (EC)DHE key exchange algorithm. For this example, I
created simple Python web server with our specified parameters which will be
covered later.

First of all, we have to generate our RSA private key + Certificate for our web
server. We will use “openssl”. We can download it here:
[[openssl]](https://wiki.openssl.org/index.php/Binaries).

Basically, Certificate contains RSA public key + another data for CERT
verification. RSA private key is self-explanatory.

Generating Certificate + RSA private key in openssl: “openssl req -new -x509
\-keyout cert.pem -out cert.pem -days 365 –nodes”

Fill the CERT info as you wish.

![](media/33668f5189d111fd9746c237c08e5afa.png)

Our newly created cert.pem is containing both certificate and RSA private key as
we can see in the picture below.

![](media/6a749f0f2609a228923708aba3e7a08b.png)

We will extract the RSA private key from cert.pem which we will be using later
in Wireshark. The cert.pem file with both RSA private key and certificate is
used in our Python server implementation later on.

Extracted RSA private key:

![](media/b28e73c5e4ccea13352e892aa32a324e.png)

We can also extract the certificate from cert.pem, save it as certificate.pem
and check containing info we filled during its creation before. We can check
these information in tool like [[certinfo]](http://www.mitec.cz/certinfo.html).

![](media/2899d45106fd0a1277577e196451f280.png)

Using Certinfo:

![](media/570ebc14d32ff140ad194a1ef92115bc.png)

In real scenario/case, we will already have some web server private key and
captured network traffic data but here, we will be implementing our own python
web server with our previously created certificate + RSA private key.

Let´s start to run some VM where we have installed python3+. For virtualization
platform I will be using VirtualBox and as Guest OS – Windows 7.

Let´s configure our VM network setting in VirtualBox:

Choose VM and go to Settings Network and enable Network adapter (Host-only
Adapter) – this settings will create Network interface only between our Host and
Guest VM machine.

![](media/0013d279077cdb0b4de04d0f3e78b7d3.png)

Start our VM and check the IP address on our newly created network interface
(Host-only Adapter). In my case the IP “192.168.56.2” is used.

![](media/5f401a3c8ad95e7bc743a75affdb8df7.png)

Now we will copy our previously created cert.pem containing both certificate and
RSA private key to the VM.

We also implement the web server in python, some optional folders/files and some
example html web content.<br/>
(Download here: [[www content]](https://github.com/Dump-GUY/Malware-analysis-and-Reverse-engineering/tree/main/TLS%20decryption%20in%20Wireshark/www))

![](media/84662255050020c9c29de43b89ef19cf.png)

The web server implementation in Python3+ is in the picture below and you can
download this example from:
[[HTTPS_WEB_SERVER.py]](https://github.com/Dump-GUY/Malware-analysis-and-Reverse-engineering/blob/main/TLS%20decryption%20in%20Wireshark/www/HTTPS_WEB_SERVER.py)

![](media/ecf6252aba887f02e5aead88ba84c55f.png)

As we can see, we configured the Python web server to meet all conditions for
TLS decryption via RSA private key method in Wireshark. (TLS version 1.2, only
cipher suites NOT implementing (EC)DHE key exchange algorithm, cert.pem
containing our RSA private key)

The used IP address is that we previously obtained from interface (Host-only
Adapter).

Now we can start our Python web server in VM.

![](media/49883670fc59a294ebddbd432f087203.png)

Start Wireshark in Host and choose interface “VirtualBox Host-Only Network”.

![](media/08d33aecc2b3568986859c73f266f968.png)

Start web browser in host and navigate to hxxps[://]192.168.56.2

![](media/4e56803a0d466241c30f1fe5e28129af.png)

As we can see our certificate is self-signed and it is not trusted (cannot be
verified). Let´s check the certificate. We got our CERT information as we
expected.

![](media/245f992d91963dd71f8e781c74541786.png)

Let´s proceed (Accept the RISK and Continue).

We reached our previously created index.html example served via our Python web
server implementation. You can download this index.html example here:
[[index.html]](https://github.com/Dump-GUY/Malware-analysis-and-Reverse-engineering/blob/main/TLS%20decryption%20in%20Wireshark/www/web/index.html)

![](media/be63d538a31a933fa47aa7bbaf732595.png)

We will download included files, exit the web browser and check the Wireshark.

We can see in Wireshark that during TLS handshake, our web browser is offering
18 cipher suites.

![](media/6fd2518649aabc956bf88d23fd4dabcc.png)

There is no HTTP traffic available and all is encrypted via TLS.

![](media/55d43c8ef9e62f4c90b2beec4d854726.png)

We can check that our Python web server is choosing TLS version 1.2 and cipher
suite “TLS_RSA_WITH_AES_256_GCM_SHA384” during TLS negotiation (Handshake) as we
previously configured.

![](media/b909f1f33ddfb2d63a00ac1efdd872b1.png)

We can also check the web server certificate information.

![](media/75580f25518fe6cf237ce12787e239c9.png)

Now is the time to decrypt TLS and obtain HTTP traffic.

According to Wireshark documentation there are 2 methods how we can perform TLS
decryption via RSA private key in Wireshark:

\-----------------------------------------------------------------------------------------------------------------------------------------------
Starting with Wireshark 3.0, a new RSA Keys dialog can be found at *Edit* -\>
*Preferences* -\> *RSA Keys*. In this dialog, use the *Add new keyfile...*
button to select a file. You will be prompted for a password if necessary. The
*Add new token...* button can be used to add keys from a HSM which might require
using *Add new provider...* to select select a DLL/.so file, and additional
vendor-specific configuration.

The RSA key file can either be a *PEM* format private key or a PKCS\#12 keystore
(typically a file with a .pfx or .p12 extension). The PKCS\#12 key is a binary
file, but the PEM format is a text file which looks like this:

-----BEGIN PRIVATE KEY-----<br/>
MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDReQzlKVeAK8b5<br/>
TRcRBhSi9IYwHX8Nqc8K4HeDRvN7HiBQQP3bhUkVekdoXpRLYVuc7A8h1BLr93Qw<br/>
...<br/>
KOi8FZl+jhG+p8vtpK5ZAIyp<br/>
-----END PRIVATE KEY-----<br/>
<br/>
The deprecated *RSA keys list* dialog may be removed at some point. To configure
keys, use the *RSA keys* dialog instead. To change the protocol for decrypted
network data, right-click on a TLS packet and use *Decode As* to change the
*Current* protocol for the *TLS port*. The *IP address* and *Port* fields are
unused.
\-----------------------------------------------------------------------------------------------------------------------------------------------

So navigate to Wireshark -\> Edit -\> Preferences -\> RSA Keys

Add new key file (Our web server private key “RSA_private_KEY.pem”) and confirm
importing.

![](media/bf4ad51e80ecfef7282b5d69a9304dd9.png)

Go back to Packet list view in Wireshark and find the first packet of TLS
protocol (DST IP of our web server). Mouse right click Decode As…

![](media/78aa396cdc13094cb04ec8bf394454ed.png)

Click OK.

![](media/20b562f4f88d4592568e7818f3fba8f0.png)

Now we can see all TLS decrypted web traffic in Wireshark.

![](media/9b9bd71d31029ac616b901ea5caf44c1.png)

We can see decrypted HTTP streams.

![](media/a11b0919a5c426c7464218132363de64.png)

We can also export all HTTP objects as we can in normal HTTP traffic when TLS is
not used.

![](media/f2bf45f98af282241dc89983820bd5c5.png)

## Conclusion:

Each of method, which was shown, has its advantages and disadvantages. You can perform TLS decryption via RSA private key not only for TLS encrypted HTTP
traffic but also for another protocols. In both methods, there are some restriction in use. I hope that this post will serve somebody as simple guide, how one can decrypt TLS traffic in Wireshark. The main point of this was to show that even if you have the RSA private key, there are situations where it cannot be used for successful TLS decryption as mentioned in post. I would also like to thank Wireshark for its one of the best and well maintained documentation (not only for the best network protocol analyzing tool).

## Useful links:

[[https://wiki.wireshark.org/TLS]](https://wiki.wireshark.org/TLS)

[[https://en.wikipedia.org/wiki/Cipher_suite]](https://en.wikipedia.org/wiki/Cipher_suite)

## Author:

[[Twitter]](https://twitter.com/vinopaljiri)

[[Github]](https://github.com/Dump-GUY)

## Download:

[[Download PDF]](https://github.com/Dump-GUY/Malware-analysis-and-Reverse-engineering/blob/main/TLS%20decryption%20in%20Wireshark/TLS%20decryption%20in%20Wireshark.pdf) 
