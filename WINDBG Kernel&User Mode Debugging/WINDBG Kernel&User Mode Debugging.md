# WINDBG Kernel&User mode debugging:<br/>Walking through System structures EPROCESS, KPROCESS, ETHREAD, KTHREAD, TEB, PEB and their using

Video: [[WINDBG Kernel&User Mode Debugging (EPROCESS, ETHREAD, TEB, PEB...)]](https://youtu.be/ngBPk5O5uhA)

## Let’s start:

### Generating shellcode 32bit and 64bit with msfvenom - metasploit framework:<br/>

32bit shellcode - msfvenom.bat -p windows/exec CMD=calc.exe -o shellcode32.sc<br/>
64bit shellcode - msfvenom.bat -p windows/x64/exec CMD=calc.exe -o shellcode64.sc<br/>

Available here: [[Shellcodes]](https://github.com/Dump-GUY/Malware-analysis-and-Reverse-engineering/tree/main/WINDBG%20Kernel%26User%20Mode%20Debugging/Samples)


### Wrap it to exe to make it simply debuggable:<br/>

shellcode2exe.bat 32 shellcode32.sc wrapped_sc32.exe<br/>
shellcode2exe.bat 64 shellcode64.sc wrapped_sc64.exe<br/>

Available here: [[Shellcodes wrapped to exe]](https://github.com/Dump-GUY/Malware-analysis-and-Reverse-engineering/tree/main/WINDBG%20Kernel%26User%20Mode%20Debugging/Samples)


### Compare the produced wraped shellcode/exe in IDA focus on API resolving - imports retrieving:<br/>
TEB -\> PEB -\> \_PEB.Ldr -\> \_PEB_LDR\_DATA.InMemoryOrderModuleList.Flink -\><br/>
\_LDR_DATA_TABLE_ENTRY.FullDllName.Buffer<br/>
\_LDR_DATA_TABLE\_ENTRY.FullDllName.MaximumLength<br/>

## Brief Information:<br/>

### Segment Registers FS(32bit) vs GS(64bit):<br/>

Used to point to operating system defined structure (manage thread-specific memory) -\> TEB<br/>
TEB -\> pointer FS:[0x30] and GS:[0x60] -\> address of Process Environment Block (PEB)<br/>

### About System structures (EPROCESS, KPROCESS, ETHREAD, KTHREAD, TEB, PEB):

TEB and PEB can be accessed from User Mode - Contains Process and thread specific information.<br/>
EPROCESS and KPROCESS can be accessed only from Kernel Mode --\> Representing Process object in Kernel.<br/>
ETHREAD and KTHREAD can be accessed only from Kernel Mode --\> Representing Thread object.<br/>
EPROCESS contains pointer to KPROCESS structure and to PEB.<br/>
ETHREAD contains pointer to KTHREAD structure and KTHREAD structure contains pointer to TEB.<br/>
<br/>
64bit processes on 64bit Processor architecture contains 1x64 bit structure of PEB and 1x64 bit structure of TEB.<br/>
32bit processes on 32bit Processor architecture contains 1x32 bit structure of PEB and 1x32 bit structure of TEB.<br/>
32bit processes on 64bit Processor architecture contains 1x32 bit structure of PEB + 1x64 bit structure of PEB and 1x32 bit structure of TEB + 1x64 bit
structure of TEB. (WoW64 emulation)<br/>

You can see below as described before (Picture from [[Hasherezade Windows
Malware Analysis
training]](https://github.com/hasherezade/malware_training_vol1))

![](media/2a7190a3f7d788e5c39ab6a017f14baf.png)

### Simple explanations EPROCESS vs KPROCESS:

When you are creating process, both the Kernel and the Executive Subsystems want
to track it.
Kernel for example wants to deal with the priority and affinity of the threads
in the process because that's going to affect scheduling.
The Executive Subsystem wants to track the process for example because of
Security Executive Subsystem wants to associate a token with the process so
security checking could occur.
The structure that the Kernel uses to track the process is the KPROCESS.
The structure that the Executive Subsystems use to track process is the
EPROCESS.
The KPROCESS is the first field of the EPROCESS, so the Executive Subsystems
allocate the EPROCESS structure and then call the Kernel to initialize the
KPROCESS.
Both structures are part of the Process Object that represents the instance of
user process.
BOTH are located in kernel memory space. The names, if I understand it well,
come from names of subsystems that interact with these structures. EPROCESS
\-executive, KPROCESS -kernel.

![](media/9ee9e4afc04a1e8993001eff357ad376.png)

## Settings for exercise:

Kernel debugging with Windbg Preview in Host -\> debugging Guest VM:

### **Guest VM:**

CMD as administrator:

bcdedit /debug on<br/>
bcdedit /dbgsettings serial debugport:1 baudrate:115200 (assuming the port is COM1)<br/>
shut down the VM<br/>

Go into the settings for our Virtualbox Windows VM:<br/>
Serial Ports -\> Port1 -\> Enable serial port<br/>
Port number COM1<br/>
Port Mode -\> Host Pipe<br/>
Uncheck “Connect to existing pipe/socket”<br/>
Path/Address -\> \\\\.\\pipe\\MalDBG<br/>
Start VM<br/>

### **HOST:**

Install Windbg Preview<br/>
Go to File -\> "Start Debugging” and select “Attach to Kernel”<br/>
Go to COM tab -\> Check Pipe and Reconnect<br/>
Resets 0<br/>
Baud Rate 115200<br/>
Port \\\\.\\pipe\\MalDBG<br/>
Uncheck Break on connection<br/>
Click OK - To attach to kernel of our VM<br/>

## Steps:

### WINDBG:

Run wrapped_sc32.exe - break on entrypoint<br/>
Run wrapped_sc64.exe - break on entrypoint<br/>
Differences between 32bit process TEB/PEB and 64bit TEB/PEB<br/>
Showing System structures like EPROCESS, KPROCESS, ETHREAD, KTHREAD<br/>

### XNTSV:

Restart VM and press F8 during boot to enter Advanced Boot Options -\> Disable Driver Signature Enforcement (To enable loading of unsigned drivers)<br/>
Run wrapped_sc64.exe - break on entrypoint - WINDBG<br/>
Run XNTSV and attach to PID of wrapped_sc64.exe:<br/>
Showing TEB/PEB<br/>
Showing System structures like EPROCESS, KPROCESS, ETHREAD, KTHREAD<br/>

## Useful commands:

Windbg commands (User Mode):<br/>
User Mode WINDBG for both (wrapped_sc32.exe, wrapped_sc64.exe):<br/>
Run exe<br/>
GO to entrypoint in Disassembly - @\$exentry<br/>
Breakpoint on entrypoint - bp @\$exentry<br/>
Continue to reach breakpoint<br/>

Examine the TEB structure:<br/>
dt ntdll!\_TEB @\$teb<br/>
Use (dt ntdll!\_TEB @\$teb -r2) for showing recursive 2 nested records<br/>

Examine the \_PEB structure:
dt ntdll!\_PEB @\$teb+0x30 or dt ntdll!_PEB @\$peb (or peb address)<br/>
dt ntdll!\_PEB\* - list all variables that contain the word \_PEB<br/>
dt ntdll!\_PEB_LDR_DATA 0x776e0200 (address pointed by ldr in PEB)<br/>
dt ntdll!\_LDR_DATA_TABLE_ENTRY 0x544768 (address pointed by \_PEB_LDR_DATA -\> InMemoryOrderModuleList)<br/>
dt ntdll!\_UNICODE_STRING 0x2b4768+0x024<br/>

Windbg Preview commands (Kernel Mode):

!process 0 0 -list all processes (Obtain Process ID of our required process end address of EPROCESS structure)<br/>
dt \_eprocess fffffa80044c4850 -Eprocess structure of process object (Check first element - address pointing to KPROCESS structure, CHECK PEB)<br/>
!process ab0 7 - 7 for getting more information about our process ID=ab0 (Check address of THREAD = address of ETHREAD structure)<br/>
dt \_Ethread fffffa8004490060 - get ETHREAD structure (Check first element - address pointing to KTHREAD structure)<br/>
Check KTHREAD structure - contains TEB<br/>

## More information and useful links:

### **Hasherezade Malware analysis course:**

<https://github.com/hasherezade/malware_training_vol1/blob/main/slides/module1/Module1_3_process.pdf><br/>
<https://github.com/hasherezade/malware_training_vol1/blob/main/slides/module1/Module1_4_wow64.pdf><br/>

### **Common WinDbg Commands:**

<http://windbg.info/doc/1-common-cmds.html><br/>

### **Tools:**

Windbg Preview - Microsoft<br/>
Windbg - Microsoft<br/>
XNTSV – <https://github.com/horsicq/xntsv><br/>
shellcode2exe - <https://github.com/repnz/shellcode2exe><br/>

## Author:

[[Twitter]](https://twitter.com/vinopaljiri)

[[Github]](https://github.com/Dump-GUY)

## Download:

[[Download PDF]](https://github.com/Dump-GUY/Malware-analysis-and-Reverse-engineering/blob/main/WINDBG%20Kernel%26User%20Mode%20Debugging/WINDBG%20Kernel%26User%20Mode%20Debugging.pdf) 
